---
phase: 03-connection-utilities
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/commands/connections.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Connection string generation works for PostgreSQL instances"
    - "Connection string generation works for Redis instances"
    - "Connection string generation works for MySQL instances"
    - "Connection string generation works for MongoDB instances"
    - "Each connection string uses correct format for its database type"
  artifacts:
    - path: "src-tauri/src/commands/connections.rs"
      provides: "Connection string generation command"
      exports: ["get_connection_string"]
      min_lines: 30
    - path: "src-tauri/src/lib.rs"
      provides: "Command registration"
      contains: "commands::connections::get_connection_string"
  key_links:
    - from: "get_connection_string"
      to: "Instance"
      via: "StateManager lookup"
      pattern: "state\\.get_instance"
---

<objective>
Create backend command to generate standard connection strings for database instances.

Purpose: Enable frontend to fetch ready-to-use connection strings for any running database instance.
Output: `get_connection_string(instance_id)` command returning properly formatted connection string.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing instance model
@src-tauri/src/models/instance.rs

# Command registration pattern
@src-tauri/src/lib.rs

# Existing command pattern
@src-tauri/src/commands/instances.rs
</context>

<tasks>

<task type="auto">
  <name>Create connection string generation command</name>
  <files>src-tauri/src/commands/connections.rs</files>
  <action>
Create a new command file `src-tauri/src/commands/connections.rs` with a `get_connection_string` Tauri command.

The command should:
1. Accept `instance_id: String` as parameter
2. Look up the instance from StateManager
3. Generate connection string based on `database_type`:

Format for each database type:
- **PostgreSQL**: `postgresql://postgres:{password}@127.0.0.1:{port}/{name}`
  - User: `postgres` (default superuser)
  - Database name: use instance `name` (lowercase, replace spaces with underscores)
- **Redis**: `redis://:{password}@127.0.0.1:{port}`
  - No username, password after `://:`
  - No database name in connection string
- **MySQL**: `mysql://root:{password}@127.0.0.1:{port}/{name}`
  - User: `root` (default superuser)
  - Database name: use instance `name` (lowercase, replace spaces with underscores)
- **MongoDB**: `mongodb://root:{password}@127.0.0.1:{port}/{name}?authSource=admin`
  - User: `root` (default superuser)
  - Database name: use instance `name` (lowercase, replace spaces with underscores)
  - Include `authSource=admin` query param

Use the existing pattern from `instances.rs`:
- Import `State`, `StateManager` from `crate::state`
- Use `tauri::State<StateManager>` parameter
- Return `Result<String, String>`
- Handle instance not found with `Err("Instance not found".to_string())`

Example structure:
```rust
use tauri::State;
use crate::state::StateManager;
use crate::models::instance::DatabaseType;

#[tauri::command]
pub async fn get_connection_string(
    instance_id: String,
    state: State<'_, StateManager>,
) -> Result<String, String> {
    // Implementation
}
```
  </action>
  <verify>
    cd src-tauri && cargo check 2>&1 | head -50
  </verify>
  <done>
Command compiles without errors and is ready for registration in lib.rs.
  </done>
</task>

<task type="auto">
  <name>Register connection string command</name>
  <files>src-tauri/src/lib.rs</files>
  <action>
Update `src-tauri/src/lib.rs` to register the new command:

1. No need to add a new module declaration (commands module already exists)
2. Add `commands::connections::get_connection_string` to the `invoke_handler!` macro

The invoke_handler should now include:
```rust
commands::connections::get_connection_string,
```

Place it after the existing instance commands for logical grouping.
  </action>
  <verify>
    cd src-tauri && cargo check 2>&1
  </verify>
  <done>
lib.rs includes get_connection_string in invoke_handler and cargo check passes.
  </done>
</task>

</tasks>

<verification>
- `cargo check` passes with no errors
- `get_connection_string` command is registered in invoke_handler
- Connection string formats are correct for all 4 database types
</verification>

<success_criteria>
- Backend can generate connection strings for PostgreSQL, Redis, MySQL, and MongoDB
- Each format follows standard connection string conventions
- Command returns proper error when instance not found
</success_criteria>

<output>
After completion, create `.planning/phases/03-connection-utilities/03-01-SUMMARY.md`
</output>
