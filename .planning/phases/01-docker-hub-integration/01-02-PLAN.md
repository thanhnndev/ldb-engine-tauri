---
phase: "01-docker-hub-integration"
plan: "02"
type: "execute"
wave: 2
depends_on:
  - "01-01"
files_modified:
  - "src-tauri/src/docker/hub.rs"
  - "src-tauri/src/docker/client.rs"
  - "src-tauri/src/commands/mod.rs"
  - "src-tauri/src/commands/images.rs"
autonomous: true

must_haves:
  truths:
    - "User can fetch tags for PostgreSQL from Docker Hub via command"
    - "User can fetch tags for Redis from Docker Hub via command"
    - "User can fetch tags for MySQL from Docker Hub via command"
    - "User can fetch tags for MongoDB from Docker Hub via command"
    - "User can pull images with progress events streamed to frontend"
  artifacts:
    - path: "src-tauri/src/docker/hub.rs"
      provides: "Docker Hub API client for fetching tags"
      exports: ["get_image_tags"]
    - path: "src-tauri/src/docker/client.rs"
      provides: "Docker daemon client for pulling images"
      exports: ["pull_image_with_progress"]
    - path: "src-tauri/src/commands/images.rs"
      provides: "Tauri commands for frontend"
      exports: ["get_docker_tags", "pull_docker_image"]
  key_links:
    - from: "src/routes/+page.svelte"
      to: "src-tauri/src/commands/images.rs"
      via: "tauri invoke"
      pattern: "invoke.*get_docker_tags"
    - from: "src/routes/+page.svelte"
      to: "src-tauri/src/docker/client.rs"
      via: "tauri event"
      pattern: "listen.*pull-progress"
---

<objective>
Implement Docker Hub API integration to fetch image tags and Docker daemon integration to pull images with progress streaming.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@src-tauri/src/docker/hub.rs
@src-tauri/src/docker/client.rs
@src-tauri/src/lib.rs

# Docker Hub API:
# - Base URL: https://hub.docker.com/v2/repositories/{image}/tags
# - Image names: library/postgres, library/redis, library/mysql, library/mongo
# - Requires pagination (page parameter)

# Supported images:
# - PostgreSQL: library/postgres
# - Redis: library/redis  
# - MySQL: library/mysql
# - MongoDB: library/mongo

# Pull progress:
# - Use bollard's CreateImageOptions for pull
# - Stream progress events via Tauri emit()
</context>

<tasks>

<task type="auto">
  <name>Implement Docker Hub API client</name>
  <files>src-tauri/src/docker/hub.rs</files>
  <action>
Create Docker Hub API client in src-tauri/src/docker/hub.rs:

```rust
use reqwest::Client;
use serde::Deserialize;

const DOCKER_HUB_API: &str = "https://hub.docker.com/v2";

#[derive(Debug, Deserialize)]
pub struct TagResponse {
    pub count: usize,
    pub next: Option<String>,
    pub previous: Option<String>,
    pub results: Vec<Tag>,
}

#[derive(Debug, Deserialize)]
pub struct Tag {
    pub name: String,
    #[serde(rename = "digest")]
    pub digest: Option<String>,
}

pub struct DockerHubClient {
    http: Client,
}

impl DockerHubClient {
    pub fn new() -> Self {
        Self {
            http: Client::new(),
        }
    }

    /// Fetch tags for a Docker Hub image (e.g., "library/postgres")
    pub async fn get_tags(&self, image: &str, page: usize) -> Result<TagResponse, String> {
        let url = format!("{}/repositories/{}/tags?page={}&page_size=20", DOCKER_HUB_API, image, page);
        
        let response = self.http
            .get(&url)
            .header("Accept", "application/json")
            .send()
            .await
            .map_err(|e| format!("Failed to fetch tags: {}", e))?;
        
        if !response.status().is_success() {
            return Err(format!("Docker Hub API error: {}", response.status()));
        }
        
        response
            .json::<TagResponse>()
            .await
            .map_err(|e| format!("Failed to parse tags: {}", e))
    }
}

impl Default for DockerHubClient {
    fn default() -> Self {
        Self::new()
    }
}
```

Export the client from docker/mod.rs.
  </action>
  <verify>
cargo check --manifest-path src-tauri/Cargo.toml compiles without errors
  </verify>
  <done>DockerHubClient::get_tags can fetch tags from Docker Hub API</done>
</task>

<task type="auto">
  <name>Implement Docker daemon client for image pull</name>
  <files>src-tauri/src/docker/client.rs</files>
  <action>
Create Docker daemon client in src-tauri/src/docker/client.rs:

```rust
use bollard::Docker;
use bollard::image::CreateImageOptions;
use futures::StreamExt;
use std::sync::Arc;
use tauri::{AppHandle, Emitter};

pub struct DockerClient {
    docker: Docker,
}

#[derive(Clone, serde::Serialize)]
pub struct PullProgress {
    pub id: String,
    pub status: String,
    pub progress: Option<String>,
    pub progress_detail: Option<ProgressDetail>,
}

#[derive(Clone, serde::Serialize)]
pub struct ProgressDetail {
    pub current: Option<u64>,
    pub total: Option<u64>,
}

impl DockerClient {
    pub fn new() -> Result<Self, String> {
        let docker = Docker::connect_with_local_defaults()
            .map_err(|e| format!("Failed to connect to Docker: {}", e))?;
        
        Ok(Self { docker })
    }

    /// Pull an image from Docker Hub with progress streaming
    pub async fn pull_image(&self, app: AppHandle, image: &str) -> Result<(), String> {
        let options = Some(CreateImageOptions {
            from_image: image,
            ..Default::default()
        });

        let mut stream = self.docker.create_image(options, None, None);

        while let Some(result) = stream.next().await {
            match result {
                Ok(info) => {
                    let progress = PullProgress {
                        id: info.id.unwrap_or_default(),
                        status: info.status.unwrap_or_default(),
                        progress: info.progress,
                        progress_detail: info.progress_detail.map(|pd| ProgressDetail {
                            current: pd.current,
                            total: pd.total,
                        }),
                    };
                    
                    // Emit progress event to frontend
                    let _ = app.emit("pull-progress", progress);
                }
                Err(e) => {
                    let _ = app.emit("pull-error", format!("Pull failed: {}", e));
                    return Err(format!("Pull failed: {}", e));
                }
            }
        }

        let _ = app.emit("pull-complete", image);
        Ok(())
    }
}

impl Default for DockerClient {
    fn default() -> Self {
        Self::new().expect("Failed to create Docker client")
    }
}
```

Export the client from docker/mod.rs.
  </action>
  <verify>
cargo check --manifest-path src-tauri/Cargo.toml compiles without errors
  </verify>
  <done>DockerClient::pull_image can pull images with progress events</done>
</task>

<task type="auto">
  <name>Create Tauri commands for images</name>
  <files>src-tauri/src/commands/images.rs</files>
  <action>
Create commands module and image commands:

1. Create src-tauri/src/commands/mod.rs:
```rust
pub mod images;
```

2. Create src-tauri/src/commands/images.rs:
```rust
use crate::docker::hub::{DockerHubClient, Tag};
use crate::docker::client::DockerClient;
use tauri::{AppHandle, State};
use std::sync::Arc;

#[derive(Clone, serde::Serialize)]
pub struct ImageTag {
    pub name: String,
}

/// Get available tags for a Docker Hub image
#[tauri::command]
pub async fn get_docker_tags(image: String) -> Result<Vec<ImageTag>, String> {
    let client = DockerHubClient::new();
    
    // Fetch all pages to get complete tag list
    let mut all_tags = Vec::new();
    let mut page = 1;
    
    loop {
        match client.get_tags(&image, page).await {
            Ok(response) => {
                let tags: Vec<ImageTag> = response.results
                    .into_iter()
                    .map(|t| ImageTag { name: t.name })
                    .collect();
                
                all_tags.extend(tags);
                
                if response.next.is_none() {
                    break;
                }
                page += 1;
            }
            Err(e) => return Err(e),
        }
    }
    
    Ok(all_tags)
}

/// Supported database images
#[tauri::command]
pub fn get_supported_images() -> Vec<(&'static str, &'static str)> {
    vec![
        ("postgres", "library/postgres"),
        ("redis", "library/redis"),
        ("mysql", "library/mysql"),
        ("mongo", "library/mongo"),
    ]
}

/// Pull a Docker image with progress events
#[tauri::command]
pub async fn pull_docker_image(app: AppHandle, image: String) -> Result<(), String> {
    let client = DockerClient::new()?;
    client.pull_image(app, &image).await
}
```

3. Update src-tauri/src/lib.rs to include commands module and register handlers:
```rust
pub mod docker;
pub mod commands;

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_opener::init())
        .invoke_handler(tauri::generate_handler![
            greet,
            commands::images::get_docker_tags,
            commands::images::get_supported_images,
            commands::images::pull_docker_image,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```
  </action>
  <verify>
cargo check --manifest-path src-tauri/Cargo.toml compiles without errors
  </verify>
  <done>Tauri commands exist: get_docker_tags, get_supported_images, pull_docker_image</done>
</task>

</tasks>

<verification>
Backend compiles. Commands can be invoked from frontend.
</verification>

<success_criteria>
- [ ] DockerHubClient fetches tags from Docker Hub API
- [ ] DockerClient pulls images with progress streaming
- [ ] Tauri commands: get_docker_tags, get_supported_images, pull_docker_image
- [ ] cargo check passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-docker-hub-integration/01-02-SUMMARY.md`
</output>
