---
phase: "02-instance-management"
plan: "02"
type: "execute"
wave: 2
depends_on: ["02-01"]
files_modified:
  - "src-tauri/src/state.rs"
  - "src-tauri/src/commands/instances.rs"
  - "src-tauri/src/commands/ports.rs"
  - "src-tauri/src/commands/mod.rs"
autonomous: true

must_haves:
  truths:
    - "System auto-detects occupied ports and suggests next available"
    - "System creates local directories for volume mounts automatically"
    - "Instance metadata persists across app restarts"
    - "Volume data can be deleted or retained on instance removal"
  artifacts:
    - path: "src-tauri/src/state.rs"
      provides: "Instance state persistence (JSON file storage)"
      exports: ["StateManager", "load_instances", "save_instances"]
    - path: "src-tauri/src/commands/ports.rs"
      provides: "Port detection and allocation"
      exports: ["get_available_port", "get_occupied_ports"]
    - path: "src-tauri/src/commands/instances.rs"
      provides: "Volume management in delete_instance command"
      features: ["volume_path_creation", "volume_cleanup_option"]
  key_links:
    - from: "commands/instances.rs"
      to: "state.rs"
      via: "StateManager"
    - from: "commands/instances.rs"
      to: "commands/ports.rs"
      via: "get_available_port()"
---

<objective>
Instance state persistence, port detection, and volume management.

Purpose: Enable instance metadata to persist across app restarts, auto-detect available ports, and manage volume directories
Output: State management module, port detection commands, volume management integration
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@src-tauri/src/commands/instances.rs (from 02-01)
@src-tauri/src/models/instance.rs (from 02-01)
@src-tauri/src/docker/client.rs

# Dependencies from Phase 1:
# - DockerClient for Docker operations
# - Instance model with DatabaseType enum
# - create_instance, start_instance, stop_instance, etc. commands
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StateManager for instance persistence</name>
  <files>src-tauri/src/state.rs</files>
  <action>
Create src-tauri/src/state.rs with:

1. StateManager struct that loads/saves instance metadata to JSON file
2. Data directory: ~/.ldb-engine/instances.json
3. Methods:
   - `load_instances()`: Load all instances from JSON file, return Vec<Instance>
   - `save_instances(instances: Vec<Instance>)`: Save instances to JSON file
   - `add_instance(instance: Instance)`: Add instance and save
   - `update_instance(instance: Instance)`: Update instance and save
   - `remove_instance(id: String)`: Remove instance by ID and save
4. Create data directory if it doesn't exist
5. Return empty Vec if file doesn't exist yet
6. Integrate with instance commands to persist instance state after create/update/delete
  </action>
  <verify>StateManager can load and save instances to JSON file in ~/.ldb-engine/</verify>
  <done>Instance metadata persists across app restarts via JSON file storage</done>
</task>

<task type="auto">
  <name>Task 2: Implement port detection commands</name>
  <files>src-tauri/src/commands/ports.rs</files>
  <action>
Create src-tauri/src/commands/ports.rs with:

1. **get_occupied_ports**: Query Docker for all running containers, extract host port mappings, return Vec<u16>
2. **get_available_port**: Accept preferred_port (optional), find next available port starting from:
   - PostgreSQL: 5432
   - Redis: 6379
   - MySQL: 3306
   - MongoDB: 27017
   - Algorithm: Check if preferred_port is available, if not increment until free (max 65535)
3. **get_next_port_for_type**: Accept database_type, return next available port for that type

Base ports by type:
- PostgreSQL: 5432
- Redis: 6379
- MySQL: 3306
- MongoDB: 27017

Use bollard to list containers and extract port bindings.
  </action>
  <verify>get_available_port returns correct base ports, skips occupied ports</verify>
  <done>System can auto-detect occupied ports and suggest available ones</done>
</task>

<task type="auto">
  <name>Task 3: Add volume management to instance commands</name>
  <files>src-tauri/src/commands/instances.rs</files>
  <action>
Update commands/instances.rs to add volume management:

1. **Volume path creation**: In create_instance, automatically create local directory for volume mount:
   - Path: ~/.ldb-engine/volumes/<instance_id>/
   - Create directory if not exists
   - Bind mount to container's data directory (/data, /var/lib/mysql)

2. **Volume cleanup in delete_instance**: Add optional parameter `delete_volume: bool`
   - Default: false (preserve data)
   - If true: Remove ~/.ldb-engine/volumes/<instance_id>/ directory after container deletion

3. **Modify CreateInstanceRequest**: Add optional port field, if not provided call get_available_port

4. **Store volume_path in Instance**: Add volume_path field to Instance struct

5. **get_instance_volume_path**: New command to get volume path for an instance
  </action>
  <verify>Volumes created at ~/.ldb-engine/volumes/<id>/, delete respects delete_volume flag</verify>
  <done>Volume directories auto-created on instance creation, optionally deleted on instance removal</done>
</task>

</tasks>

<verification>
- StateManager persists instance metadata to ~/.ldb-engine/instances.json
- Port detection correctly identifies occupied ports from running containers
- Volume directories created automatically at ~/.ldb-engine/volumes/<id>/
- Delete with delete_volume=true removes both container and volume directory
</verification>

<success_criteria>
Instance state persists across restarts, ports auto-detected, volumes managed automatically
</success_criteria>

<output>
After completion, create `.planning/phases/02-instance-management/02-02-SUMMARY.md`
</output>
