---
phase: "02-instance-management"
plan: "01"
type: "execute"
wave: 1
depends_on: []
files_modified:
  - "src-tauri/src/commands/instances.rs"
  - "src-tauri/src/commands/mod.rs"
  - "src-tauri/src/lib.rs"
autonomous: true

must_haves:
  truths:
    - "User can create database instances with name, type, image, password"
    - "User can start, stop, restart, delete instances"
    - "System maps password to correct Docker env vars per database type"
    - "Backend commands exist for all instance lifecycle operations"
  artifacts:
    - path: "src-tauri/src/commands/instances.rs"
      provides: "Instance CRUD and lifecycle Tauri commands"
      exports: ["create_instance", "start_instance", "stop_instance", "restart_instance", "delete_instance", "list_instances", "get_instance_status"]
    - path: "src-tauri/src/models/instance.rs"
      provides: "Instance data model with database type enum"
      contains: "struct Instance, enum DatabaseType"
  key_links:
    - from: "src/lib/components/InstanceList.svelte"
      to: "commands/instances.rs"
      via: "invoke()"
      pattern: "create_instance|start_instance|stop_instance|list_instances"
---

<objective>
Backend commands for instance CRUD operations and lifecycle management (create, start, stop, restart, delete, list, inspect).

Purpose: Establish the core Docker container management layer before adding state persistence and UI
Output: Rust Tauri commands that interface with bollard Docker SDK
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@src-tauri/src/docker/client.rs (existing DockerClient with pull_image)
@src-tauri/src/commands/images.rs (existing command pattern)
@src/lib/types.ts (existing SUPPORTED_IMAGES, ImageTag types)

# Phase 1 created:
# - DockerClient struct with pull_image method
# - get_docker_tags, get_supported_images, pull_docker_image commands
# - UI components: ImageCard, TagList, PullProgress
# - SUPPORTED_IMAGES with postgres, redis, mysql, mongo
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Instance model in Rust</name>
  <files>src-tauri/src/models/instance.rs</files>
  <action>
Create src-tauri/src/models/ directory and instance.rs with:
1. DatabaseType enum: PostgreSQL, Redis, MySQL, MongoDB
2. Instance struct with fields: id (UUID), name, database_type, image, tag, port, root_password, status, created_at
3. InstanceStatus enum: Running, Stopped, Error, Creating
4. Implement Default for InstanceStatus (Stopped)
5. Add serde derive for serialization/deserialization
6. Export module in lib.rs
  </action>
  <verify>File exists with DatabaseType enum, Instance struct with all required fields</verify>
  <done>DatabaseType enum and Instance struct available for use in commands</done>
</task>

<task type="auto">
  <name>Task 2: Implement instance lifecycle commands</name>
  <files>src-tauri/src/commands/instances.rs</files>
  <action>
Create commands/instances.rs with the following Tauri commands using bollard:

1. **create_instance**: Accept CreateInstanceRequest {name, database_type, image, tag, password, port}, create container (not start), return Instance
   - Use bollard::container::CreateContainerOptions
   - Map database_type to correct env vars:
     - PostgreSQL: POSTGRES_PASSWORD=<password>
     - MySQL: MYSQL_ROOT_PASSWORD=<password>
     - MongoDB: MONGO_INITDB_ROOT_USERNAME=root, MONGO_INITDB_ROOT_PASSWORD=<password>
     - Redis: CMD ["redis-server", "--requirepass", <password>] (no ENV)
   - Map database_type to default volume mount path:
     - PostgreSQL/MongoDB: /data
     - MySQL: /var/lib/mysql
     - Redis: /data

2. **start_instance**: Accept container_id, call start_container, return Instance with Running status

3. **stop_instance**: Accept container_id, call stop_container with 10s timeout, return Instance with Stopped status

4. **restart_instance**: Accept container_id, call restart_container with 10s timeout, return Instance

5. **delete_instance**: Accept container_id, delete_container with force=true option

6. **list_instances**: Return all containers (including stopped), map to Instance structs with status from inspect

7. **get_instance_status**: Accept container_id, return current status from inspect (running, exited, created, etc.)

Use DockerClient from client.rs for all Docker operations.
  </action>
  <verify>All 7 commands compile, use bollard API correctly</verify>
  <done>create_instance, start_instance, stop_instance, restart_instance, delete_instance, list_instances, get_instance_status all functional</done>
</task>

<task type="auto">
  <name>Task 3: Register commands in lib.rs</name>
  <files>src-tauri/src/commands/mod.rs, src-tauri/src/lib.rs</files>
  <action>
1. Add `pub mod models;` to commands/mod.rs
2. Add models module in lib.rs: `pub mod models;`
3. Register all instance commands in lib.rs invoke_handler:
   - commands::instances::create_instance
   - commands::instances::start_instance
   - commands::instances::stop_instance
   - commands::instances::restart_instance
   - commands::instances::delete_instance
   - commands::instances::list_instances
   - commands::instances::get_instance_status
  </action>
  <verify>cargo check passes without errors</verify>
  <done>All instance commands registered and accessible from frontend via invoke()</done>
</task>

</tasks>