---
phase: "02-instance-management"
plan: "03"
type: "execute"
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - "src/lib/components/InstanceList.svelte"
  - "src/lib/components/InstanceForm.svelte"
  - "src/lib/components/InstanceCard.svelte"
  - "src/lib/components/InstanceControls.svelte"
  - "src/lib/types.ts"
  - "src/routes/+page.svelte"
autonomous: false

must_haves:
  truths:
    - "User can view list of all instances with status"
    - "User can create new instance via form"
    - "User can start, stop, restart, delete instances via controls"
    - "System displays real-time status (Running, Stopped, Error)"
    - "Delete prompts for volume cleanup option"
  artifacts:
    - path: "src/lib/components/InstanceList.svelte"
      provides: "Main container showing all instances"
    - path: "src/lib/components/InstanceForm.svelte"
      provides: "Form for creating new instances"
    - path: "src/lib/components/InstanceCard.svelte"
      provides: "Card showing single instance with status"
    - path: "src/lib/components/InstanceControls.svelte"
      provides: "Start/Stop/Restart/Delete buttons for instance"
  key_links:
    - from: "src/routes/+page.svelte"
      to: "InstanceList.svelte"
      via: "import"
    - from: "InstanceList.svelte"
      to: "src-tauri/commands/instances.rs"
      via: "invoke()"
---

<objective>
Frontend UI for instance management: list view, create form, controls, and real-time status display.

Purpose: Complete the user-facing instance management interface with all required interactions
Output: Svelte 5 components for viewing, creating, and controlling database instances
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@src/lib/types.ts (existing ImageTag, SUPPORTED_IMAGES)
@src/lib/components/ImageCard.svelte (existing from Phase 1)
@src-tauri/src/commands/instances.rs (from 02-01)
@src-tauri/src/commands/ports.rs (from 02-02)
@src-tauri/src/state.rs (from 02-02)

# Dependencies:
# - Instance model and lifecycle commands from 02-01
# - Port detection and state management from 02-02
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Instance TypeScript types</name>
  <files>src/lib/types.ts</files>
  <action>
Update src/lib/types.ts to add:

1. InstanceStatus type: "running" | "stopped" | "error" | "creating"
2. DatabaseType type: "postgres" | "redis" | "mysql" | "mongo"
3. Instance interface: id, name, database_type, image, tag, port, root_password, status, created_at, volume_path
4. CreateInstanceRequest interface: name, database_type, image, tag, password, port (optional)
5. Update SUPPORTED_IMAGES to include default_port for each database type
  </action>
  <verify>TypeScript types match Rust Instance model</verify>
  <done>TypeScript has complete Instance type matching backend</done>
</task>

<task type="auto">
  <name>Task 2: Create InstanceCard component</name>
  <files>src/lib/components/InstanceCard.svelte</files>
  <action>
Create src/lib/components/InstanceCard.svelte:

1. Props: instance (Instance), onStart, onStop, onRestart, onDelete callbacks
2. Display:
   - Instance name (heading)
   - Database type icon/badge
   - Image:tag display
   - Port number
   - Status badge (color-coded: green=running, gray=stopped, red=error)
3. Use InstanceControls for action buttons
4. Show loading state during operations
5. Use Svelte 5 runes ($props, $state)
  </action>
  <verify>InstanceCard displays all instance info with status badge</verify>
  <done>Single instance card renders with all details and controls</done>
</task>

<task type="auto">
  <name>Task 3: Create InstanceControls component</name>
  <files>src/lib/components/InstanceControls.svelte</files>
  <action>
Create src/lib/components/InstanceControls.svelte:

1. Props: instance (Instance), disabled state
2. Buttons:
   - Start (only shown when stopped)
   - Stop (only shown when running)
   - Restart (only shown when running)
   - Delete (always shown, with confirmation)
3. Delete confirmation:
   - Show checkbox "Delete associated volume data?"
   - Confirm button, Cancel button
4. Loading spinner during operations
5. Emit events or call callbacks for actions
  </action>
  <verify>Controls show correct buttons based on status, delete has volume checkbox</verify>
  <done>InstanceControls provides all lifecycle buttons with proper state handling</done>
</task>

<task type="auto">
  <name>Task 4: Create InstanceForm component</name>
  <files>src/lib/components/InstanceForm.svelte</files>
  <action>
Create src/lib/components/InstanceForm.svelte:

1. Fields:
   - Instance name (text input, required)
   - Database type (select: PostgreSQL, Redis, MySQL, MongoDB)
   - Image version/tag (select from available tags - use get_docker_tags)
   - Root password (password input, required for PostgreSQL/MySQL, optional for Redis)
   - Port (number input, auto-suggested, can be changed)
2. Auto-fetch tags when database type changes
3. Auto-suggest port when database type changes (from get_available_port)
4. Validation:
   - Name: required, 3-50 chars
   - Password: required for postgres/mysql, optional for redis/mongo
   - Port: 1024-65535
5. Submit button, Cancel button
6. Use Svelte 5 runes ($state, $derived)
  </action>
  <verify>Form validates all fields, fetches tags, suggests available port</verify>
  <done>InstanceForm allows creating new instances with all required fields</done>
</task>

<task type="auto">
  <name>Task 5: Create InstanceList component</name>
  <files>src/lib/components/InstanceList.svelte</files>
  <action>
Create src/lib/components/InstanceList.svelte:

1. State:
   - instances: Instance[] (load via list_instances command)
   - showForm: boolean
   - loading: boolean
   - polling: boolean (for status updates)
2. Display:
   - Header with "Instances" title and "New Instance" button
   - If showForm: InstanceForm
   - List of InstanceCard components
   - Empty state: "No instances yet. Create one to get started."
3. Polling for status:
   - Poll get_instance_status every 5 seconds for running instances
   - Update instance status in real-time
4. Handle form submit:
   - Call create_instance command
   - Add new instance to list
   - Close form
5. Handle instance actions:
   - Start: call start_instance, update status
   - Stop: call stop_instance, update status
   - Restart: call restart_instance, update status
   - Delete: call delete_instance (with delete_volume flag), remove from list
  </action>
  <verify>InstanceList shows all instances, allows CRUD, polls for status</verify>
  <done>InstanceList is main container managing all instance interactions</done>
</task>

<task type="checkpoint:human-verify">
  <what-built>Complete instance management UI</what-built>
  <how-to-verify>
1. Run the Tauri app: `npm run tauri dev`
2. Navigate to main page
3. Click "New Instance" button
4. Fill form: select PostgreSQL, choose tag, enter name and password
5. Submit - instance should appear in list with Stopped status
6. Click Start - status should change to Running
7. Click Stop - status should change to Stopped
8. Click Delete - checkbox should appear for volume deletion
9. Verify form validation (try submitting empty form)
10. Verify port suggestion when changing database type
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
- InstanceList displays all instances with real-time status
- InstanceForm creates new instances with validation
- InstanceControls provides start/stop/restart/delete with confirmation
- Status polls every 5 seconds for running instances
- Delete shows checkbox for volume data option
</verification>

<success_criteria>
User can fully manage database instances: create, start, stop, restart, delete with volume option
</success_criteria>

<output>
After completion, create `.planning/phases/02-instance-management/02-03-SUMMARY.md`
</output>
